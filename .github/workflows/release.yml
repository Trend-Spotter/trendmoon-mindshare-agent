# Publish package on main branch if it's tagged with 'v*'

name: release & publish workflow

# Controls when the action will run.
on:
  # Triggers the workflow on push events but only for the master branch
  push:
    tags:
      - 'v*'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  publish-packages:
    name: Push Packages
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest]
        python-versions: ["3.11"]
    steps:
      - name: Get version from tag
        id: tag_name
        run: |
          echo ::set-output name=current_version::${GITHUB_REF#refs/tags/v}
        shell: bash

      - uses: actions/checkout@v5
        with:
          submodules: 'recursive'

      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.python-versions }}
      - name: Install and configure Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ matrix.poetry-version }}
          virtualenvs-create: true
          virtualenvs-in-project: false
          virtualenvs-path: ~/my-custom-path
          installer-parallel: true
      - uses: addnab/docker-run-action@v3
        with:
            image: valory/open-autonomy-user:latest
            options: -v ${{ github.workspace }}:/work
            run: |
              echo "Pushing Packages"
              cd /work
              export AUTHOR=$(grep 'service' packages/packages.json | awk -F/ '{print $2}' | head -1)
              autonomy init --reset --author $AUTHOR --ipfs --remote
              autonomy push-all

      - name: Update Changelog
        uses: heinrichreimer/github-changelog-generator-action@v2.1.1
        id: changelog
        with:
            token: ${{ secrets.GH_TOKEN }}
            issues: true
            issuesWoLabels: true
            pullRequests: true
            prWoLabels: true
            unreleased: true
            addSections: '{"documentation":{"prefix":"**Documentation:**","labels":["documentation"]}}'

      - uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: Update Changelog for PR
          file_pattern: CHANGELOG.md
          branch: main
          push_options: '--force'

      - name: Install Project
        run: |
            make install

      - name: Push packages To Registry
        run: |
            make hashes

      - name: create github release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          body: ${{ steps.changelog.outputs.changelog }}
          files: packages/packages.json
          draft: false
          prerelease: false
  publish-images:
    name: Publish Docker Images
    runs-on: ${{ matrix.os }}
    needs:
      - "publish-packages"
    strategy:
      matrix:
        os: [ubuntu-latest]
        python-version: ["3.11"]
    env:
      DOCKER_USER: ${{secrets.DOCKER_USER}}
      DOCKER_PASSWORD: ${{secrets.DOCKER_PASSWORD}}
    steps:
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          fetch-depth: 0
      - uses: addnab/docker-run-action@v3
        with:
          image: valory/open-autonomy-user:latest
          options: -v ${{ github.workspace }}:/work
          run: |
            echo "Setting Tag Images"
            cd /work
            apt-get update && apt-get install git -y || exit 1
            git config --global --add safe.directory /work
            export TAG=$(git describe --exact-match --tags $(git rev-parse HEAD)) || exit 1
            if [ $? -eq 0 ]; then
                export TAG=`echo $TAG | sed 's/^v//'`
            else
                echo "You are not on a tagged branch"
                exit 1
            fi
            echo VERSION=$TAG> env.sh
            echo AUTHOR=$(grep 'service/' packages/packages.json | awk -F/ '{print $2}' | head -1) >> env.sh
            echo SERVICE=$(grep 'service/' packages/packages.json | awk -F/ '{print $3}' | head -1) >> env.sh
            echo AGENT=$(grep 'agent/' packages/packages.json | awk -F/ '{print $3}' | head -1) >> env.sh
            echo DEFAULT_IMAGE_TAG=$(cat packages/packages.json | grep agent/ | awk -F: '{print $2}' | tr -d '", ' | head -n 1) >> env.sh
            cat env.sh
      - uses: addnab/docker-run-action@v3
        name: Build Images
        with:
          image: valory/open-autonomy-user:latest
          options: -v ${{ github.workspace }}:/work -e DOCKER_USER -e DOCKER_PASSWORD
          shell: bash
          run: |
            echo "Building Docker Images"
            cd /work
            source env.sh || exit 1
            echo "Building images for $AUTHOR for service $SERVICE"
            autonomy init --reset --author $AUTHOR --ipfs --remote
            autonomy fetch $AUTHOR/$SERVICE --service --local || exit 1
            cd $SERVICE || exit 1
            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USER --password-stdin || exit 1
            docker buildx create --name multiarch-builder --driver docker-container --bootstrap --use
            autonomy build-image --builder multiarch-builder --platform linux/amd64,linux/arm64 --pre-install-command "apt install gfortran pkg-config libopenblas-dev liblapack-dev python3-dev libssl-dev libxml2-dev libxslt-dev libjpeg-dev -y" --push || exit 1
            autonomy build-image --builder multiarch-builder --platform linux/amd64,linux/arm64 --pre-install-command "apt install gfortran pkg-config libopenblas-dev liblapack-dev python3-dev libssl-dev libxml2-dev libxslt-dev libjpeg-dev -y" --push --version $VERSION || exit 1
  build-agent-runner:
    needs:
      - "publish-packages"
      runs-on: ${{ matrix.os }}
      strategy:
        matrix:
          os: [windows-latest, macos-14, macos-14-large]
      defaults:
        run:
          shell: bash
      steps:
        - uses: actions/checkout@v3
        - uses: actions/setup-python@v5
          id: setup-python
          with:
            python-version: "3.11"
        - name: Add Python to PATH
          run: |
            echo "${{ steps.setup-python.outputs.python-path }}" >> $GITHUB_PATH
        - name: prepare sign things windows
          if: runner.os == 'Windows'
          run: |
            echo Setup Certificate 
            echo "${{secrets.SM_CLIENT_CERT_FILE_B64 }}" | base64 --decode > /d/Certificate_pkcs12.p12 
            echo "Set Variables!"
            echo "::set-output name=version::${GITHUB_REF#refs/tags/v}" 
            echo "SM_HOST=${{ secrets.SM_HOST }}" >> "$GITHUB_ENV" 
            echo "SM_API_KEY=${{ secrets.SM_API_KEY }}" >> "$GITHUB_ENV" 
            echo "SM_KEY_PAIR_ALIAS=${{ secrets.SM_KEY_PAIR_ALIAS }}" >> "$GITHUB_ENV" 
            echo "SM_CLIENT_CERT_FILE=D:\\Certificate_pkcs12.p12" >> "$GITHUB_ENV" 
            echo "SM_CLIENT_CERT_PASSWORD=${{ secrets.SM_CLIENT_CERT_PASSWORD }}" >> "$GITHUB_ENV" 
            echo "C:\Program Files (x86)\Windows Kits\10\App Certification Kit" >> $GITHUB_PATH 
            echo "C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools" >> $GITHUB_PATH 
            echo "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools" >> $GITHUB_PATH 
          shell: bash  
        - name: Setup SSM KSP on windows latest
          if: runner.os == 'Windows'
          run: | 
            curl -X GET  https://one.digicert.com/signingmanager/api-ui/v1/releases/smtools-windows-x64.msi/download -H "x-api-key:%SM_API_KEY%" -o smtools-windows-x64.msi 
            msiexec /i smtools-windows-x64.msi /quiet /qn 
            smksp_registrar.exe list 
            smctl.exe keypair ls 
            C:\Windows\System32\certutil.exe -csp "DigiCert Signing Manager KSP" -key -user 
            smksp_cert_sync.exe 
          shell: cmd  
        - name: Install and configure Poetry
          run: pip install poetry
        - name: prepare agent
          run: |
            make install
            poetry run autonomy init --reset --author "dummy_author_git_ci" --ipfs --remote
            make hash_id
            make agent_id
            make ./agent/ethereum_private_key.txt
          

