# ------------------------------------------------------------------------------
#
#   Copyright 2025 xiuxiuxar
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import json
from abc import ABC
from enum import Enum
from typing import TYPE_CHECKING, Any, cast
from pathlib import Path
from datetime import UTC, datetime, timedelta
from dataclasses import dataclass
from collections.abc import Generator

from aea.protocols.base import Message
from aea.skills.behaviours import State, FSMBehaviour
from aea.configurations.base import PublicId
from aea.protocols.dialogue.base import Dialogue as BaseDialogue

from packages.eightballer.connections.dcxt import PUBLIC_ID as DCXT_PUBLIC_ID
from packages.valory.protocols.contract_api import ContractApiMessage
from packages.eightballer.contracts.erc_20.contract import Erc20
from packages.eightballer.protocols.tickers.message import TickersMessage
from packages.xiuxiuxar.skills.mindshare_app.models import Coingecko, Trendmoon
from packages.xiuxiuxar.skills.mindshare_app.dialogues import (
    ContractApiDialogue,
)


DEFAULT_ENCODING = "utf-8"
PRICE_COLLECTION_TIMEOUT_SECONDS = 15


@dataclass
class PriceRequest:
    """Price request."""

    symbol: str
    exchange_id: str
    ledger_id: str
    ticker_dialogue: Any
    request_timestamp: datetime


ALLOWED_ASSETS: dict[str, list[dict[str, str]]] = {
    "base": [
        # BASE-chain Uniswap tokens
        {
            "address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
            "symbol": "USDC",
            "coingecko_id": "usd-coin",
        },
        {
            "address": "0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22",
            "symbol": "cbETH",
            "coingecko_id": "coinbase-wrapped-staked-eth",
        },
        {
            "address": "0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf",
            "symbol": "cbBTC",
            "coingecko_id": "coinbase-wrapped-btc",
        },
    ]
}


if TYPE_CHECKING:
    from packages.xiuxiuxar.skills.mindshare_app.models import Coingecko, Trendmoon
    from packages.eightballer.protocols.tickers.custom_types import Ticker


class MindshareabciappEvents(Enum):
    """Events for the fsm."""

    REJECTED = "REJECTED"
    FAILED = "FAILED"
    NO_SIGNAL = "NO_SIGNAL"
    RESET = "RESET"
    SIGNAL_GENERATED = "SIGNAL_GENERATED"
    EXIT_SIGNAL = "EXIT_SIGNAL"
    APPROVED = "APPROVED"
    DONE = "DONE"
    POSITIONS_CHECKED = "POSITIONS_CHECKED"
    RESUME = "RESUME"
    ERROR = "ERROR"
    RETRIES_EXCEEDED = "RETRIES_EXCEEDED"
    AT_LIMIT = "AT_LIMIT"
    EXECUTED = "EXECUTED"
    RETRY = "RETRY"
    CAN_TRADE = "CAN_TRADE"


class MindshareabciappStates(Enum):
    """States for the fsm."""

    DATACOLLECTIONROUND = "datacollectionround"
    PORTFOLIOVALIDATIONROUND = "portfoliovalidationround"
    RISKEVALUATIONROUND = "riskevaluationround"
    PAUSEDROUND = "pausedround"
    CHECKSTAKINGKPIROUND = "checkstakingkpiround"
    SIGNALAGGREGATIONROUND = "signalaggregationround"
    HANDLEERRORROUND = "handleerrorround"
    POSITIONMONITORINGROUND = "positionmonitoringround"
    ANALYSISROUND = "analysisround"
    TRADECONSTRUCTIONROUND = "tradeconstructionround"
    SETUPROUND = "setupround"
    EXECUTIONROUND = "executionround"


class BaseState(State, ABC):
    """Base class for states."""

    _state: MindshareabciappStates = None

    supported_protocols: dict[PublicId, list] = {}

    def setup(self) -> None:
        """Perform the setup."""
        self.started = False
        self._is_done = False
        self._message = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False  # Initially, the state is not done
        self._message = None
        self._performative_to_dialogue_class = None  # Will be initialized lazily

    @property
    def performative_to_dialogue_class(self) -> dict:
        """Get the performative to dialogue class mapping, initializing if needed."""
        if self._performative_to_dialogue_class is None:
            self._performative_to_dialogue_class = {
                ContractApiMessage.Performative.GET_STATE: self.context.contract_api_dialogues,
                ContractApiMessage.Performative.GET_RAW_TRANSACTION: self.context.contract_api_dialogues,
                TickersMessage.Performative.GET_TICKER: self.context.tickers_dialogues,
            }
        return self._performative_to_dialogue_class

    @property
    def coingecko(self) -> "Coingecko":
        """Get the CoinGecko API client."""
        return cast("Coingecko", self.context.coingecko)

    @property
    def trendmoon(self) -> "Trendmoon":
        """Get the Trendmoon API client."""
        return cast("Trendmoon", self.context.trendmoon)

    def act(self) -> None:
        """Perform the act."""
        self._is_done = True
        self._event = MindshareabciappEvents.DONE

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Current event."""
        return self._event

    @classmethod
    def _get_request_nonce_from_dialogue(cls, dialogue: BaseDialogue) -> str:
        """Get the request nonce for the request, from the protocol's dialogue."""
        return dialogue.dialogue_label.dialogue_reference[0]

    def get_dialogue_callback_request(self):
        """Get callback request for dialogue handling."""

        def callback_request(message: Message, dialogue: BaseDialogue, behaviour: Any) -> None:
            """The callback request."""
            if message.protocol_id in self.supported_protocols:
                self.context.logger.debug(f"Message: {message} {dialogue}: {behaviour}")
                self._message = message
                self.supported_protocols.get(message.protocol_id).append(message)

                # Check if this dialogue has a validation function
                if hasattr(dialogue, "validation_func") and callable(dialogue.validation_func):
                    try:
                        # Call the validation function
                        is_valid = dialogue.validation_func(message, dialogue)
                        if is_valid:
                            self.context.logger.info(
                                "Message validated successfully for dialogue "
                                f"{dialogue.dialogue_label.dialogue_reference[0]}"
                            )
                        else:
                            self.context.logger.info(
                                "Message validation failed for dialogue "
                                f"{dialogue.dialogue_label.dialogue_reference[0]}"
                            )
                    except Exception as e:
                        self.context.logger.exception(f"Error in validation function: {e}")

                return

            self.context.logger.info(
                f"Message not supported: {message.protocol_id}. Supported protocols: {self.supported_protocols}"
            )

        return callback_request

    def submit_msg(
        self,
        performative: Message.Performative,
        connection_id: str,
        **kwargs: Any,
    ) -> BaseDialogue:
        """Submit a message and return the dialogue."""

        dialogue_class: BaseDialogue = self.performative_to_dialogue_class[performative]

        # Create message and dialogue
        msg, dialogue = dialogue_class.create(counterparty=connection_id, performative=performative, **kwargs)
        msg._sender = str(self.context.skill_id)  # noqa: SLF001

        request_nonce = self._get_request_nonce_from_dialogue(dialogue)
        self.context.requests.request_id_to_callback[request_nonce] = self.get_dialogue_callback_request()
        self.context.outbox.put_message(message=msg)
        return dialogue


# Define states


class SetupRound(BaseState):
    """This class implements the behaviour of the state SetupRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.SETUPROUND
        self.setup_success: bool = False
        self.setup_data: dict[str, Any] = {}
        self.started: bool = False

    def setup(self) -> None:
        """Perform the setup."""
        super().setup()
        self._is_done = False

    def _initialize_state(self) -> None:
        """Initialize persistent storage for the agent."""
        self.context.logger.info("Initializing persistent storage...")

        store_path = self.context.params.store_path

        if not store_path:
            store_path = "./persistent_data"
            self.setup_data["store_path"] = store_path

        store_path = Path(store_path)
        store_path.mkdir(parents=True, exist_ok=True)

        # Initialize storage files
        files_to_initialize = {
            "positions.json": {"positions": [], "last_updated": None},
            "signals.json": {"signals": [], "last_signal": None},
            "performance.json": {"trades": [], "metrics": {}},
            "state.json": {"last_round": None, "error_count": 0},
        }

        for filename, default_content in files_to_initialize.items():
            file_path = store_path / filename
            if not file_path.exists():
                with open(file_path, "w", encoding="utf-8") as f:
                    json.dump(default_content, f, indent=2)

        self.context.store_path = store_path
        self.context.logger.info(f"Persistent storage initialized at: {store_path}")

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        if self.started:
            return
        self.started = True

        try:
            self._initialize_state()
            self.setup_success = True
            self._event = MindshareabciappEvents.DONE
        except Exception as e:
            self.context.logger.exception(f"Setup failed. {e!s}")
            self.context.error_context = {
                "error_type": "setup_error",
                "error_message": str(e),
                "originating_round": str(self._state),
            }
            self._event = MindshareabciappEvents.ERROR

        finally:
            self._is_done = True


class DataCollectionRound(BaseState):
    """This class implements the behaviour of the state DataCollectionRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.DATACOLLECTIONROUND
        self.collected_data: dict[str, Any] = {}
        self.started_at: datetime | None = None
        self.collection_initialized = False
        self.pending_tokens: list[dict[str, str]] = []
        self.completed_tokens: list[dict[str, str]] = []
        self.failed_tokens: list[dict[str, str]] = []

    def setup(self) -> None:
        """Perform the setup."""
        super().setup()
        self._is_done = False

    def _initialize_collection(self) -> None:
        """Initialize data collection on first run."""
        if self.collection_initialized:
            return

        self.context.logger.info("Initializing data collection...")

        self.pending_tokens = ALLOWED_ASSETS["base"].copy()
        self.completed_tokens = []
        self.failed_tokens = []

        self.collected_data = {
            "ohlcv": {},
            "current_prices": {},
            "market_data": {},
            "social_data": {},
            "fundamental_data": {},
            "onchain_data": {},
            "collection_timestamp": datetime.now(UTC).isoformat(),
            "errors": [],
            "cache_hits": 0,
            "api_calls": 0,
        }

        self.started_at = datetime.now(UTC)
        self.collection_initialized = True
        self.context.logger.info(f"Initialized batch collection for {len(self.pending_tokens)} tokens")

    def _collect_token_data(self, token_info: dict[str, str]) -> None:
        """Collect data for a single token."""
        symbol = token_info["symbol"]
        address = token_info["address"]

        self.context.logger.debug(f"Collecting data for {symbol} ({address})")

        try:
            ohlcv_data, price_data = self._fetch_coingecko_data(token_info)

            if ohlcv_data:
                self.collected_data["ohlcv"][symbol] = ohlcv_data
            if price_data:
                self.collected_data["current_prices"][symbol] = price_data

            self.completed_tokens.append(token_info)
            self.context.logger.debug(f"Successfully collected data for {symbol}")

        except (ValueError, KeyError, ConnectionError, TimeoutError) as e:
            self.context.logger.warning(f"Failed to collect data for {symbol}: {e}")
            self.failed_tokens.append(token_info)
            self.collected_data["errors"].append(f"Error processing {symbol} ({address}): {e}")

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")

        try:
            self._initialize_collection()

            while self.pending_tokens:
                token_info = self.pending_tokens.pop(0)
                self._collect_token_data(token_info)

            self._finalize_collection()
            self._event = MindshareabciappEvents.DONE if self._is_data_sufficient() else MindshareabciappEvents.ERROR
            self._is_done = True

        except Exception as e:
            self.context.logger.exception(f"Data collection failed: {e}")
            self.context.error_context = {
                "error_type": "data_collection_error",
                "error_message": str(e),
                "originating_round": str(self._state),
            }
            self._event = MindshareabciappEvents.ERROR
            self._is_done = True

    def _store_collected_data(self) -> None:
        """Store collected data to persistent storage."""
        if not self.context.store_path:
            self.context.logger.warning("No store path available, skipping data storage")
            return

        try:
            data_file = self.context.store_path / "collected_data.json"
            with open(data_file, "w", encoding="utf-8") as f:
                json.dump(self.collected_data, f, indent=2)
            self.context.logger.info(f"Collected data stored to {data_file}")
        except Exception as e:
            self.context.logger.exception(f"Failed to store collected data: {e}")

    def _log_collection_summary(self) -> None:
        """Log collection summary."""
        completed = len(self.completed_tokens)
        failed = len(self.failed_tokens)
        total = completed + failed
        collection_time = self.collected_data.get("collection_time", 0)
        api_calls = self.collected_data.get("api_calls", 0)

        self.context.logger.info(
            f"Batch collection summary: {completed}/{total} successful, "
            f"{failed} failed, {collection_time:.1f}s, {api_calls} API calls"
        )

    def _is_data_sufficient(self) -> bool:
        """Check if collected data is sufficient for analysis."""
        min_required = max(1, len(ALLOWED_ASSETS["base"]) * self.context.params.data_sufficiency_threshold)
        successful_count = len(self.completed_tokens)
        return successful_count >= min_required

    def _finalize_collection(self) -> None:
        """Finalize data collection and store results."""
        if self.started_at:
            collection_time = (datetime.now(UTC) - self.started_at).total_seconds()
            self.collected_data["collection_time"] = collection_time

        self._store_collected_data()
        self._log_collection_summary()

    def _fetch_coingecko_data(self, token_info: dict[str, str]) -> tuple[dict | None, dict | None]:
        """Fetch OHLCV and price data from CoinGecko API.

        Args:
        ----
            token_info: Dict containing symbol, address, and coingecko_id

        Returns:
        -------
            Tuple of (ohlcv_data, price_data) or (None, None) on error

        Expected data structure:
        - price_data: Current market data with price, volume, market cap, 24h change
        - ohlcv_data: Historical OHLCV data for the last 90 days

        """
        symbol = token_info["symbol"]
        coingecko_id = token_info["coingecko_id"]

        try:
            # Fetch current price and market data for the token
            self.collected_data["api_calls"] += 1
            price_data = self._get_current_price_data(coingecko_id)

            # Fetch historical OHLCV data for the token
            self.collected_data["api_calls"] += 1
            ohlcv_data = self._get_historical_ohlcv_data(coingecko_id)

            if not ohlcv_data or not price_data:
                error_msg = "No data returned from CoinGecko API"
                raise ValueError(error_msg)

            return ohlcv_data, price_data

        except (ValueError, KeyError, ConnectionError, TimeoutError) as e:
            self.context.logger.warning(f"CoinGecko API error for {symbol}: {e}")
            return None, None

    def _get_current_price_data(self, coingecko_id: str) -> dict | None:
        """Get current price and market data for a token."""

        return self.context.coingecko.get_current_price(coingecko_id)

    def _get_historical_ohlcv_data(self, coingecko_id: str) -> dict | None:
        """Get historical OHLCV data for a token."""

        return self.context.coingecko.get_historical_ohlcv(coingecko_id, days=90)


class PausedRound(BaseState):
    """This class implements the behaviour of the state PausedRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.PAUSEDROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.DONE


class CheckStakingKPIRound(BaseState):
    """This class implements the behaviour of the state CheckStakingKPIRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.CHECKSTAKINGKPIROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.DONE


class HandleErrorRound(BaseState):
    """This class implements the behaviour of the state HandleErrorRound."""

    RETRYABLE_ERRORS = {
        "ConnectionError": True,
    }

    NON_RETRYABLE_ERRORS = {
        "configuration_error": False,
    }

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.HANDLEERRORROUND
        self._retry_states = {}

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.DONE


class PositionMonitoringRound(BaseState):
    """This class implements the behaviour of the state PositionMonitoringRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.POSITIONMONITORINGROUND
        self.positions_to_exit: list[dict[str, Any]] = []
        self.position_updates: list[dict[str, Any]] = []
        self.pending_positions: list[dict[str, Any]] = []
        self.completed_positions: list[dict[str, Any]] = []
        self.monitoring_initialized: bool = False
        self.started_data: datetime | None = None

    def setup(self) -> None:
        """Perform the setup."""
        self._is_done = False
        self.positions_to_exit = []
        self.position_updates = []
        self.pending_positions = []
        self.completed_positions = []
        self.monitoring_initialized = False
        self.started_data = None
        super().setup()

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")

        try:
            self._initialize_monitoring()

            if not self.pending_positions and not self.completed_positions:
                self.context.logger.info("No open positions to monitor")
                self._event = MindshareabciappEvents.POSITIONS_CHECKED
                self._is_done = True
                return

            if self.pending_positions:
                position = self.pending_positions.pop(0)
                self._monitor_single_position(position)

                total_positions = len(self.completed_positions) + len(self.pending_positions)
                self.context.logger.debug(
                    f"Monitored position {position['symbol']} "
                    f"({len(self.completed_positions)}/{total_positions} complete)"
                )

                if self.pending_positions:
                    return

            self._finalize_monitoring()

        except Exception as e:
            self.context.logger.exception(f"Position monitoring failed: {e!s}")
            self.context.error_context = {
                "error_type": "position_monitoring_error",
                "error_message": str(e),
                "originating_round": str(self._state),
            }
            self._event = MindshareabciappEvents.ERROR
            self._is_done = True

    def _initialize_monitoring(self) -> None:
        """Initialize position monitoring on first call."""
        if self.monitoring_initialized:
            return

        self.context.logger.info("Initializing position monitoring...")

        # Load open positions from persistent storage
        positions = self._load_open_positions()
        self.pending_positions = positions.copy()
        self.completed_positions = []
        self.positions_to_exit = []
        self.position_updates = []

        self.started_at = datetime.now(UTC)
        self.monitoring_initialized = True

        self.context.logger.info(f"Initialized monitoring for {len(self.pending_positions)} positions")

        self._is_done = True
        self._event = MindshareabciappEvents.POSITIONS_CHECKED

    def _monitor_single_position(self, position: dict[str, Any]) -> None:
        """Monitor a single position for exit conditions."""
        try:
            position_updated = self._monitor_position(position)

            if position_updated.get("exit_signal"):
                self.positions_to_exit.append(position_updated)
                self.context.logger.info(
                    f"Exit signal detected for {position['symbol']}: {position_updated['exit_reason']}"
                )
            else:
                self.position_updates.append(position_updated)

            self.completed_positions.append(position_updated)

        except (KeyError, ValueError, TypeError) as e:
            self.context.logger.warning(f"Failed to monitor position {position.get('symbol', 'unknown')}: {e}")
            # Add to completed anyway to prevent getting stuck
            self.completed_positions.append(position)
        except Exception as e:
            self.context.logger.exception(
                f"Unexpected error monitoring position {position.get('symbol', 'unknown')}: {e}"
            )
            # Add to completed anyway to prevent getting stuck
            self.completed_positions.append(position)

    def _finalize_monitoring(self) -> None:
        """Finalize monitoring and determine transition."""
        if self.started_at:
            monitoring_time = (datetime.now(UTC) - self.started_at).total_seconds()
            self.context.logger.info(
                f"Position monitoring completed in {monitoring_time:.1f}s "
                f"({len(self.completed_positions)} positions processed)"
            )

        # Store updated positions
        all_updated_positions = self.position_updates + self.positions_to_exit
        if all_updated_positions:
            self._update_positions_storage(all_updated_positions)

        # Determine transition based on exit signals
        if self.positions_to_exit:
            self.context.positions_to_exit = self.positions_to_exit
            self.context.logger.info(f"Found {len(self.positions_to_exit)} positions to exit")
            self._event = MindshareabciappEvents.EXIT_SIGNAL
        else:
            self._event = MindshareabciappEvents.POSITIONS_CHECKED

        self._is_done = True

    def _load_open_positions(self) -> list[dict[str, Any]]:
        """Load open positions from persistent storage."""
        if not self.context.store_path:
            return []

        positions_file = self.context.store_path / "positions.json"
        if not positions_file.exists():
            return []

        try:
            with open(positions_file, encoding="utf-8") as f:
                data = json.load(f)
                return [pos for pos in data.get("positions", []) if pos.get("status") == "open"]
        except (FileNotFoundError, PermissionError, OSError) as e:
            self.context.logger.warning(f"Failed to load positions file: {e}")
            return []
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.context.logger.warning(f"Failed to parse positions data: {e}")
            return []
        except Exception as e:
            self.context.logger.exception(f"Unexpected error loading positions: {e}")
            return []

    def _monitor_position(self, position: dict[str, Any]) -> dict[str, Any]:
        """Monitor a single position for exit conditions."""
        symbol = position["symbol"]
        entry_price = position["entry_price"]
        stop_loss = position.get("stop_loss")
        take_profit = position.get("take_profit")
        position_size = position["position_size"]

        # Get current price from collected data
        current_price = self._get_current_price(symbol)
        if current_price is None:
            self.context.logger.warning(f"No current price data for {symbol}")
            return {**position, "exit_signal": False}

        # Calculate current P&L
        unrealized_pnl = (current_price - entry_price) * position_size
        pnl_percentage = ((current_price - entry_price) / entry_price) * 100

        # Update position with current data
        updated_position = {
            **position,
            "current_price": current_price,
            "unrealized_pnl": unrealized_pnl,
            "pnl_percentage": pnl_percentage,
            "last_updated": datetime.now(UTC).isoformat(),
            "exit_signal": False,
            "exit_reason": None,
        }

        # Check stop-loss conditions
        if stop_loss and self._check_stop_loss(current_price, stop_loss):
            updated_position.update(
                {"exit_signal": True, "exit_reason": "stop_loss", "exit_price": current_price, "exit_type": "stop_loss"}
            )
            return updated_position

        # Check take-profit conditions
        if take_profit and self._check_take_profit(current_price, take_profit):
            updated_position.update(
                {
                    "exit_signal": True,
                    "exit_reason": "take_profit",
                    "exit_price": current_price,
                    "exit_type": "take_profit",
                }
            )
            return updated_position

        # Update trailing stop if configured
        return self._update_trailing_stop(updated_position, current_price)

    def _get_current_price(self, symbol: str) -> float | None:
        """Get current price for a symbol from collected data."""
        price = None

        try:
            # Check if we have collected data available
            if not self.context.store_path:
                return price

            data_file = self.context.store_path / "collected_data.json"
            if not data_file.exists():
                return price

            with open(data_file, encoding="utf-8") as f:
                collected_data = json.load(f)

            # Get current price from collected price data
            current_prices = collected_data.get("current_prices", {})
            if symbol in current_prices:
                price_data = current_prices[symbol]
                price = price_data.get("usd")  # All assets are priced in USD from CoinGecko

        except (FileNotFoundError, PermissionError, OSError) as e:
            self.context.logger.warning(f"Failed to access price data file for {symbol}: {e}")
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.context.logger.warning(f"Failed to parse price data for {symbol}: {e}")
        except Exception as e:
            self.context.logger.exception(f"Unexpected error getting current price for {symbol}: {e}")
        return price

    def _check_stop_loss(self, current_price: float, stop_loss: float) -> bool:
        """Check if stop-loss condition is triggered."""
        return current_price <= stop_loss

    def _check_take_profit(self, current_price: float, take_profit: float) -> bool:
        """Check if take-profit condition is triggered."""
        return current_price >= take_profit

    def _update_trailing_stop(self, position: dict[str, Any], current_price: float) -> dict[str, Any]:
        """Update trailing stop if configured."""
        if not position.get("trailing_stop_enabled"):
            return position

        trailing_distance = position.get("trailing_distance", 0.05)  # 5% default
        current_stop = position.get("stop_loss")

        new_stop = current_price * (1 - trailing_distance)
        if current_stop is None or new_stop > current_stop:
            position["stop_loss"] = new_stop
            self.context.logger.info(f"Updated trailing stop for {position['symbol']}: {new_stop:.6f}")

        return position

    def _update_positions_storage(self, updated_positions: list[dict[str, Any]]) -> None:
        """Update positions in persistent storage."""
        if not self.context.store_path:
            return

        positions_file = self.context.store_path / "positions.json"

        try:
            # Load existing data
            existing_data = {"positions": [], "last_updated": None}
            if positions_file.exists():
                with open(positions_file, encoding="utf-8") as f:
                    existing_data = json.load(f)

            # Update positions with new data
            existing_positions = {pos["position_id"]: pos for pos in existing_data.get("positions", [])}

            for updated_pos in updated_positions:
                position_id = updated_pos["position_id"]
                existing_positions[position_id] = updated_pos

            all_positions = list(existing_positions.values())

            # Summary statistics
            open_positions = [pos for pos in all_positions if pos.get("status") == "open"]
            total_unrealized_pnl = sum(pos.get("unrealized_pnl", 0) for pos in open_positions)
            total_portfolio_value = sum(pos.get("entry_value_usdc", 0) for pos in open_positions)

            # Save updated data
            updated_data = {
                "positions": all_positions,
                "last_updated": datetime.now(UTC).isoformat(),
                "total_positions": len(all_positions),
                "open_positions": len(open_positions),
                "total_unrealized_pnl": round(total_unrealized_pnl, 2),
                "total_portfolio_value": round(total_portfolio_value, 2),
            }

            with open(positions_file, "w", encoding="utf-8") as f:
                json.dump(updated_data, f, indent=2)

            self.context.logger.info(
                f"Updated {len(updated_positions)} positions in storage "
                f"(Total P&L: ${total_unrealized_pnl:.2f}, "
                f"Total Portfolio Value: ${total_portfolio_value:.2f})"
            )

        except Exception as e:
            self.context.logger.exception(f"Failed to update positions storage: {e}")


class PortfolioValidationRound(BaseState):
    """This class implements the behaviour of the state PortfolioValidationRound."""

    supported_protocols = {
        ContractApiMessage.protocol_id: [],
    }

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.PORTFOLIOVALIDATIONROUND
        self.validation_initialized: bool = False
        self.portfolio_metrics: dict[str, Any] = {}
        self.open_positions: list[dict[str, Any]] = []
        self.validation_result: str = ""
        self.pending_contract_calls: list[ContractApiDialogue] = []
        self.contract_responses: dict[str, Any] = {}
        self.capital_loading_complete: bool = False
        self.contract_call_submitted: bool = False

    def setup(self) -> None:
        """Perform the setup."""
        super().setup()
        self._is_done = False
        self.validation_initialized = False
        self.portfolio_metrics = {}
        self.open_positions = []
        self.validation_result = ""
        self.pending_contract_calls = []
        self.contract_responses = {}
        self.capital_loading_complete = False
        self.contract_call_submitted = False
        for k in self.supported_protocols:
            self.supported_protocols[k] = []

    def act(self) -> None:
        """Perform the act using simple state-based flow."""
        try:
            # Initialize validation on first call
            if not self.validation_initialized:
                self.context.logger.info(f"Entering {self._state} state.")
                self._initialize_validation()

                if not self._load_portfolio_data():
                    self.context.logger.error("Failed to load portfolio data")
                    self._event = MindshareabciappEvents.ERROR
                    self._is_done = True
                    return

            # Submit contract call if not already submitted
            if not self.contract_call_submitted:
                self.context.logger.info("Submitting USDC balance contract call")
                self._load_available_capital_async()
                return  # Exit early, let FSM cycle for async response

            # Check for contract responses if call submitted but not complete
            if not self.capital_loading_complete:
                self._check_contract_responses()
                if not self.capital_loading_complete:
                    return  # Still waiting for response, let FSM cycle

            # Proceed with validation once capital loading is complete
            validation_checks = [
                self._check_position_limits(),
                self._check_available_capital(),
                self._check_exposure_limits(),
            ]

            can_trade = all(validation_checks)
            self._log_validation_summary()

            if can_trade:
                self.context.logger.info("Portfolio validation passed - can proceed with new trades")
                self._event = MindshareabciappEvents.CAN_TRADE
            else:
                self.context.logger.info(f"Portfolio validation failed: {self.validation_result}")
                self._event = MindshareabciappEvents.AT_LIMIT

            self._is_done = True

        except Exception as e:
            self.context.logger.exception(f"Portfolio validation failed: {e}")
            self.context.error_context = {
                "error_type": "portfolio_validation_error",
                "error_message": str(e),
                "originating_round": str(self._state),
            }
            self._event = MindshareabciappEvents.ERROR
            self._is_done = True

    def _initialize_validation(self) -> None:
        """Initialize portfolio validation on first call."""
        if self.validation_initialized:
            return

        self.context.logger.info("Initializing portfolio validation...")

        self.portfolio_metrics = {
            "max_positions": self.context.params.max_positions,
            "current_positions": 0,
            "available_capital_usdc": 0.0,
            "total_portfolio_value": 0.0,
            "total_exposure": 0.0,
            "max_exposure_per_position": self.context.params.max_exposure_per_position,
            "max_total_exposure": self.context.params.max_total_exposure,
            "min_capital_buffer": self.context.params.min_capital_buffer,
        }

        self.validation_initialized = True

    def _load_portfolio_data(self) -> bool:
        """Load portfolio data from persistent storage."""
        try:
            if not self.context.store_path:
                self.context.logger.warning("No store path available")
                return False

            positions_file = self.context.store_path / "positions.json"
            if positions_file.exists():
                with open(positions_file, encoding="utf-8") as f:
                    positions_data = json.load(f)

                self.open_positions = [
                    pos for pos in positions_data.get("positions", []) if pos.get("status") == "open"
                ]

                self.portfolio_metrics["current_positions"] = len(self.open_positions)
                self.portfolio_metrics["total_portfolio_value"] = positions_data.get("total_portfolio_value", 0.0)

                total_exposure = sum(pos.get("entry_value_usdc", 0.0) for pos in self.open_positions)
                self.portfolio_metrics["total_exposure"] = total_exposure

            else:
                self.context.logger.info("No open positions found - assuming empty portfolio")
                self.open_positions = []

            return True

        except (FileNotFoundError, PermissionError, OSError) as e:
            self.context.logger.exception(f"Failed to access portfolio files: {e}")
            return False
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.context.logger.exception(f"Failed to parse portfolio data: {e}")
            return False
        except Exception as e:
            self.context.logger.exception(f"Unexpected error loading portfolio data: {e}")
            return False

    def _load_available_capital_async(self) -> None:
        """Load available capital from USDC balance in the agent's SAFE asynchronously."""
        try:
            target_chains = ["base"]
            chain = target_chains[0] if target_chains else "base"

            safe_addresses = self.context.params.safe_contract_addresses

            # Handle case where safe_addresses might be a string instead of dict
            if isinstance(safe_addresses, str):
                self.context.logger.info(f"Safe addresses is a string: {safe_addresses}")
                try:
                    safe_addresses_dict = json.loads(safe_addresses)
                    safe_address = safe_addresses_dict.get(chain)
                except json.JSONDecodeError:
                    self.context.logger.warning(f"Failed to parse safe_addresses JSON string: {safe_addresses}")
                    safe_address = None
            elif isinstance(safe_addresses, dict):
                safe_address = safe_addresses.get(chain)
            else:
                self.context.logger.warning(f"Unexpected safe_addresses type: {type(safe_addresses)}")
                safe_address = None

            if not safe_address:
                self.context.logger.warning(f"No SAFE address found for chain {chain}")
                self.portfolio_metrics["available_capital_usdc"] = 0.0
                self.capital_loading_complete = True
                return

            usdc_addresses = {
                "base": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
            }

            usdc_address = usdc_addresses.get(chain)
            if not usdc_address:
                self.context.logger.warning(f"No USDC address found for chain {chain}")
                self.portfolio_metrics["available_capital_usdc"] = 0.0
                self.capital_loading_complete = True
                return

            # Submit async contract call for USDC balance
            self._submit_usdc_balance_request(chain, safe_address, usdc_address)
            self.contract_call_submitted = True

        except Exception as e:
            self.context.logger.exception(f"Failed to load available capital: {e}")
            self.portfolio_metrics["available_capital_usdc"] = 0.0
            self.capital_loading_complete = True

    def _submit_usdc_balance_request(self, chain: str, safe_address: str, usdc_address: str) -> None:
        """Submit a contract call request for USDC balance."""
        try:
            self.context.logger.info(f"Requesting USDC balance for {safe_address} on {chain}")

            # Submit the contract call
            dialogue = self.submit_msg(
                performative=ContractApiMessage.Performative.GET_RAW_TRANSACTION,
                connection_id="valory/ledger:0.19.0",
                contract_address=usdc_address,
                contract_id=str(Erc20.contract_id),
                callable="balance_of",
                ledger_id="ethereum",  # Use ethereum ledger for Base chain (L2)
                kwargs=ContractApiMessage.Kwargs({"account": safe_address, "chain_id": "base"}),
            )

            # Add validation function and metadata
            dialogue.validation_func = self._validate_usdc_balance_response
            dialogue.chain = chain
            dialogue.safe_address = safe_address
            dialogue.usdc_address = usdc_address

            request_nonce = self._get_request_nonce_from_dialogue(dialogue)
            self.context.requests.request_id_to_callback[request_nonce] = self.get_dialogue_callback_request()

            # Track the pending call
            self.pending_contract_calls.append(dialogue)

            self.context.logger.debug(f"Submitted USDC balance request for {safe_address}")

        except Exception as e:
            self.context.logger.exception(f"Failed to submit USDC balance request: {e}")
            self.portfolio_metrics["available_capital_usdc"] = 0.0
            self.capital_loading_complete = True

    def _validate_usdc_balance_response(self, message: Message, dialogue: ContractApiDialogue) -> bool:
        """Validate USDC balance response message."""
        try:
            if message.performative == ContractApiMessage.Performative.RAW_TRANSACTION:
                if hasattr(message, "raw_transaction") and message.raw_transaction:
                    balance = message.raw_transaction.body.get("int")
                    if balance is not None:
                        # Store the response
                        self.contract_responses[dialogue.dialogue_label.dialogue_reference[0]] = {
                            "balance": int(balance),
                            "chain": dialogue.chain,
                            "safe_address": dialogue.safe_address,
                        }
                        self.context.logger.info(f"Received USDC balance: {balance}")
                        return True

            elif message.performative == ContractApiMessage.Performative.ERROR:
                self.context.logger.warning(f"Contract API error: {message.message}")

            return False

        except Exception as e:
            self.context.logger.exception(f"Error validating USDC balance response: {e}")
            return False

    def _check_contract_responses(self) -> None:
        """Check if contract responses have arrived and process them."""
        try:
            # Process any received responses
            for dialogue in self.pending_contract_calls.copy():
                request_nonce = dialogue.dialogue_label.dialogue_reference[0]

                if request_nonce in self.contract_responses:
                    response = self.contract_responses[request_nonce]

                    # Process USDC balance response
                    if "balance" in response:
                        balance_raw = response["balance"]
                        usdc_balance = float(balance_raw) / (10**6)
                        self.portfolio_metrics["available_capital_usdc"] = usdc_balance
                        self.context.logger.info(f"Available USDC capital: ${usdc_balance:.2f}")
                        self.capital_loading_complete = True

                    # Remove from pending
                    self.pending_contract_calls.remove(dialogue)

            # If we still have pending calls, keep waiting (no timeout logic)
            if self.pending_contract_calls and not self.capital_loading_complete:
                return  # Keep waiting for responses

            # If no pending calls or we have responses, mark as complete
            if not self.pending_contract_calls and not self.capital_loading_complete:
                # No responses received, use fallback
                self.portfolio_metrics["available_capital_usdc"] = 1000.0
                self.capital_loading_complete = True
                self.context.logger.info("No contract responses received, using fallback capital value")

        except Exception as e:
            self.context.logger.exception(f"Error checking contract responses: {e}")
            self.portfolio_metrics["available_capital_usdc"] = 1000.0
            self.capital_loading_complete = True

    def _check_position_limits(self) -> bool:
        """Check if the number of open positions exceeds the limit."""
        max_positions = self.portfolio_metrics["max_positions"]
        current_positions = self.portfolio_metrics["current_positions"]

        if current_positions >= max_positions:
            self.validation_result = f"Max positions limit reached ({current_positions}/{max_positions})"
            self.context.logger.info(self.validation_result)
            return False

        self.context.logger.info(f"Position limit check: PASSED - {current_positions}/{max_positions} positions")
        return True

    def _check_available_capital(self) -> bool:
        """Check if there is enough available capital to open a new position."""
        available_capital = self.portfolio_metrics["available_capital_usdc"]
        min_capital_buffer = self.portfolio_metrics["min_capital_buffer"]

        if available_capital <= min_capital_buffer:
            self.validation_result = (
                f"Insufficient available capital (${available_capital:.2f} <= ${min_capital_buffer:.2f})"
            )
            self.context.logger.info(self.validation_result)
            return False

        min_position_size = self.context.params.min_position_size_usdc
        available_for_trading = available_capital - min_capital_buffer

        if available_for_trading < min_position_size:
            self.validation_result = (
                f"Insufficient available capital for trading (${available_for_trading:.2f} < ${min_position_size:.2f})"
            )
            self.context.logger.info(self.validation_result)
            return False

        self.context.logger.info(
            f"Available capital check: PASSED - {available_capital:.2f} > {min_capital_buffer:.2f}"
        )
        return True

    def _check_exposure_limits(self) -> bool:
        """Check if the total exposure exceeds the limit."""
        total_exposure = self.portfolio_metrics["total_exposure"]
        max_total_exposure = self.portfolio_metrics["max_total_exposure"]
        available_capital = self.portfolio_metrics["available_capital_usdc"]

        total_portfolio_value = total_exposure + available_capital

        if total_portfolio_value > 0:
            exposure_percentage = (total_exposure / total_portfolio_value) * 100

            if exposure_percentage >= max_total_exposure:
                self.validation_result = (
                    f"Total exposure exceeds maximum limit ({exposure_percentage:.1f}% > {max_total_exposure:.1f}%)"
                )
                self.context.logger.info(self.validation_result)
                return False

        max_exposure_per_position = self.portfolio_metrics["max_exposure_per_position"]
        max_new_position_value = (total_portfolio_value * max_exposure_per_position) / 100
        available_for_trading = available_capital - self.portfolio_metrics["min_capital_buffer"]
        if max_new_position_value > available_for_trading:
            self.context.logger.info(
                f"Position size will be limited by available capital (${available_for_trading:.2f}) "
                f"rather than exposure limit (${max_new_position_value:.2f})"
            )

        exposure_percentage = (total_exposure / total_portfolio_value * 100) if total_portfolio_value > 0 else 0
        self.context.logger.info(
            f"Exposure limit check: PASSED - {exposure_percentage:.1f}% exposure < {max_total_exposure:.1f}% limit"
        )
        return True

    def _log_validation_summary(self) -> None:
        """Log the validation summary."""
        metrics = self.portfolio_metrics

        self.context.logger.info("=== Portfolio Validation Summary ===")
        self.context.logger.info(f"Open Positions: {metrics['current_positions']}/{metrics['max_positions']}")
        self.context.logger.info(f"Available Capital: ${metrics['available_capital_usdc']:.2f}")
        self.context.logger.info(f"Total Exposure: ${metrics['total_exposure']:.2f}")

        if metrics["total_exposure"] + metrics["available_capital_usdc"] > 0:
            total_value = metrics["total_exposure"] + metrics["available_capital_usdc"]
            exposure_pct = (metrics["total_exposure"] / total_value) * 100
            self.context.logger.info(f"Portfolio Exposure: {exposure_pct:.1f}%")

        if self.open_positions:
            self.context.logger.info("Current Positions:")
            for pos in self.open_positions:
                symbol = pos.get("symbol", "Unknown")
                value = pos.get("entry_value_usdc", 0)
                pnl = pos.get("unrealized_pnl", 0)
                self.context.logger.info(f"  {symbol}: ${value:.2f} (P&L: ${pnl:.2f})")

        self.context.logger.info("====================================")

    @property
    def can_add_position(self) -> bool:
        """Check if we can add a new position based on current constraints."""
        return (
            self.portfolio_metrics["current_positions"] < self.portfolio_metrics["max_positions"]
            and self.portfolio_metrics["available_capital_usdc"] > self.portfolio_metrics["min_capital_buffer"]
        )

    @property
    def available_trading_capital(self) -> float:
        """Get the amount of capital available for new trades."""
        return max(0, self.portfolio_metrics["available_capital_usdc"] - self.portfolio_metrics["min_capital_buffer"])


class AnalysisRound(BaseState):
    """This class implements the behaviour of the state AnalysisRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.ANALYSISROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.DONE


class SignalAggregationRound(BaseState):
    """This class implements the behaviour of the state SignalAggregationRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.SIGNALAGGREGATIONROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.SIGNAL_GENERATED


class RiskEvaluationRound(BaseState):
    """This class implements the behaviour of the state RiskEvaluationRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.RISKEVALUATIONROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.APPROVED


class TradeConstructionRound(BaseState):
    """This class implements the behaviour of the state TradeConstructionRound."""

    supported_protocols = {
        TickersMessage.protocol_id: [],
    }

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.TRADECONSTRUCTIONROUND
        self.construction_initialized: bool = False
        self.trade_signal: dict[str, Any] = {}
        self.constructed_trade: dict[str, Any] = {}
        self.market_data: dict[str, Any] = {}
        self.risk_parameters: dict[str, Any] = {}
        self.pending_price_requests: list[str] = []
        self.price_collection_started: bool = False
        self.started_at: datetime | None = None

    def setup(self) -> None:
        """Setup the state."""
        self._is_done = False
        self.construction_initialized = False
        self.trade_signal = {}
        self.constructed_trade = {}
        self.market_data = {}
        self.risk_parameters = {}
        self.pending_price_requests = []
        self.price_collection_started = False
        self.started_at = None
        for k in self.supported_protocols:
            self.supported_protocols[k] = []

    def act(self) -> Generator:
        """Perform the act."""
        try:
            if self._process_trade_construction():
                self._event = MindshareabciappEvents.DONE
                self._is_done = True
            elif self._is_timeout_reached():
                self._event = MindshareabciappEvents.ERROR
                self._is_done = True

        except Exception as e:
            self.context.logger.exception(f"Error in {self._state} state: {e!s}")
            self.context.error_context = {
                "error_type": "trade_construction_error",
                "error_message": str(e),
                "originating_round": str(self._state),
            }
            self._event = MindshareabciappEvents.ERROR
            self._is_done = True

        return None

    def _process_trade_construction(self) -> bool:
        """Process the trade construction workflow step by step."""
        if not self.construction_initialized:
            self.context.logger.info(f"Entering {self._state} state.")
            self._initialize_construction()

            if not self._load_trade_signal():
                self.context.logger.error("Failed to load trade signal from previous round.")
                self._set_error_state()
                return False

        if not self.price_collection_started:
            self.context.logger.info("Starting CowSwap price collection.")
            self._start_price_collection()
            return False

        if not self._check_price_collection_complete():
            return False

        construction_steps = [
            (self._process_price_responses, "Failed to process price responses"),
            (self._construct_trade_parameters, "Failed to construct trade parameters"),
            (self._validate_constructed_trade, "Failed to validate constructed trade."),
        ]

        for step_func, error_msg in construction_steps:
            if not step_func():
                self.context.logger.error(error_msg)
                self._set_error_state()
                return False

        self._store_constructed_trade()
        self._log_construction_summary()
        self.context.logger.info("Trade construction completed successfully.")
        return True

    def _is_timeout_reached(self) -> bool:
        """Check if timeout has been reached during price collection."""
        return self.started_at and datetime.now(UTC) - self.started_at > timedelta(
            seconds=PRICE_COLLECTION_TIMEOUT_SECONDS
        )

    def _set_error_state(self) -> None:
        """Set the error state and mark as done."""
        self._event = MindshareabciappEvents.ERROR
        self._is_done = True

    def _initialize_construction(self) -> None:
        """Initialize the construction."""
        if self.construction_initialized:
            return

        self.context.logger.info("Initializing trade construction.")

        self.risk_parameters = {
            "strategy": self.context.params.trading_strategy,
            "max_slippage": self.context.params.max_slippage_bps / 10000,
            "stop_loss_multiplier": self.context.params.stop_loss_atr_multiplier,
            "take_profit_ratio": self.context.params.take_profit_risk_ratio,
            "min_position_size": self.context.params.min_position_size_usdc,
            "max_position_size": self.context.params.max_position_size_usdc,
        }

        self.construction_initialized = True

    def _load_trade_signal(self) -> bool:
        """Load the trade signal from the previous round."""
        try:
            if hasattr(self.context, "approved_trade_signal") and self.context.approved_trade_signal:
                self.trade_signal = self.context.approved_trade_signal
                self.context.logger.info(
                    f"Loaded approved trade signal for {self.trade_signal.get('symbol', 'Unknown')}"
                )
                return True

            if not self.context.store_path:
                self.context.logger.warning("No store path available, skipping trade signal loading.")
                return False

            signals_file = self.context.store_path / "signals.json"
            if not signals_file.exists():
                self.context.logger.warning("No signals file found")
                return False

            with open(signals_file, encoding="utf-8") as f:
                signals_data = json.load(f)

            latest_signal = signals_data.get("last_signal")

            if not latest_signal or latest_signal.get("status") != "approved":
                self.context.logger.warning("No approved signal found, skipping trade signal loading.")
                return False

            self.trade_signal = latest_signal
            self.context.logger.info(f"Loaded approved trade signal for {self.trade_signal.get('symbol', 'Unknown')}")
            return True

        except Exception as e:
            self.context.logger.exception(f"Error loading trade signal: {e!s}")
            return False

    def _start_price_collection(self) -> None:
        """Start price collection for the trade signal."""
        try:
            symbol = self.trade_signal.get("symbol")
            if not symbol:
                self.context.logger.error("No symbol in trade signal")
                return

            token_info = self._get_token_info(symbol)
            if not token_info:
                self.context.logger.error(f"Failed to get token info for {symbol}")
                return

            position_size_usdc = self.trade_signal.get("position_size_usdc")

            price_request = self._submit_cowswap_ticker_request(token_info, position_size_usdc)
            if price_request:
                self.pending_price_requests.append(price_request)
                self.price_collection_started = True
                self.started_at = datetime.now(UTC)
                self.context.logger.info(f"Started price collection for {symbol}")

        except Exception as e:
            self.context.logger.exception(f"Error requesting market prices: {e!s}")

    def _get_token_info(self, symbol: str) -> dict[str, Any] | None:
        """Get token info from allowed assets."""
        for token in ALLOWED_ASSETS["base"]:
            if token.get("symbol") == symbol:
                return token
        return None

    def _submit_cowswap_ticker_request(
        self, token_info: dict[str, str], position_size_usdc: float
    ) -> PriceRequest | None:
        """Submit a price request to the dxct connection."""
        try:
            symbol = token_info.get("symbol")

            trading_pair = f"{symbol}/USDC"
            params = []

            def encode_dict(d: dict) -> bytes:
                """Encode a dictionary to a hex string."""
                return json.dumps(d).encode(DEFAULT_ENCODING)

            params.append({"asset_a": symbol, "asset_b": "USDC", "params": encode_dict({"amount": position_size_usdc})})

            for param in params:
                ticker_dialogue = self.submit_msg(
                    TickersMessage.Performative.GET_TICKER,
                    connection_id=str(DCXT_PUBLIC_ID),
                    exchange_id="cowswap",
                    ledger_id="base",
                    **param,
                )

            ticker_dialogue.validation_func = self._validate_ticker_msg
            ticker_dialogue.exchange_id = "cowswap"
            ticker_dialogue.ledger_id = "base"
            ticker_dialogue.symbol = symbol
            ticker_dialogue.trading_pair = trading_pair

            price_request = PriceRequest(
                symbol=symbol,
                exchange_id="cowswap",
                ledger_id="base",
                ticker_dialogue=ticker_dialogue,
                request_timestamp=datetime.now(UTC),
            )

            self.context.logger.info(f"Submitted ticker request for {trading_pair}")
            return price_request

        except Exception as e:
            self.context.logger.exception(f"Error submitting ticker request: {e!s}")
            return None

    def _validate_ticker_msg(self, ticker_msg: TickersMessage, _dialogue: BaseDialogue) -> bool:
        """Validate the ticker message."""
        try:
            if ticker_msg is None:
                return False

            if not isinstance(ticker_msg, TickersMessage):
                return False

            if ticker_msg.performative == TickersMessage.Performative.ERROR:
                self.context.logger.warning(
                    f"Received error from CowSwap: {getattr(ticker_msg, 'error_msg', 'Unknown error')}"
                )
                return False

            if ticker_msg.performative == TickersMessage.Performative.TICKER and ticker_msg.ticker is not None:
                self.context.logger.info(f"Received valid ticker: {ticker_msg.ticker.symbol}")
                return True

            return False

        except Exception as e:
            self.context.logger.exception(f"Error validating ticker message: {e!s}")
            return False

    def _check_price_collection_complete(self) -> bool:
        """Check if all price collection is complete."""
        try:
            # Check if we have received responses for all requests
            received_responses = len(self.supported_protocols.get(TickersMessage.protocol_id, []))
            expected_responses = len(self.pending_price_requests)

            if received_responses < expected_responses:
                self.context.logger.debug(f"Waiting for price responses: {received_responses}/{expected_responses}")
                return False

            # Validate all received messages
            for price_request in self.pending_price_requests:
                dialogue = price_request.ticker_dialogue
                if not dialogue.validation_func(dialogue.last_incoming_message, dialogue):
                    self.context.logger.error(f"Invalid ticker message for {price_request.symbol}")
                    return False

            return True

        except Exception as e:
            self.context.logger.exception(f"Error checking price collection completion: {e}")
            return False

    def _process_price_responses(self) -> bool:
        """Process the collected price responses from CowSwap."""
        try:
            if not self.pending_price_requests:
                self.context.logger.error("No price requests to process")
                return False

            # Get the price request (should be only one for the target symbol)
            price_request = self.pending_price_requests[0]
            dialogue = price_request.ticker_dialogue
            ticker_msg = dialogue.last_incoming_message

            if not ticker_msg or not ticker_msg.ticker:
                self.context.logger.error("No ticker data in response")
                return False

            ticker: Ticker = ticker_msg.ticker

            # Extract pricing data from CowSwap ticker
            current_price = float(ticker.bid)  # Use bid price for buying
            bid_price = float(ticker.bid)
            ask_price = float(ticker.ask)

            # Store market data
            self.market_data = {
                "current_price": current_price,
                "bid_price": bid_price,
                "ask_price": ask_price,
                "symbol": ticker.symbol,
                "exchange": "cowswap",
                "timestamp": ticker.datetime,
                "cowswap_ticker": ticker.dict(),
                # Calculate effective spread
                "spread": (ask_price - bid_price) / current_price if current_price > 0 else 0,
                "volume_24h": getattr(ticker, "volume", 0),
                "high_24h": getattr(ticker, "high", current_price),
                "low_24h": getattr(ticker, "low", current_price),
            }

            self.context.logger.info(
                f"Processed CowSwap pricing for {ticker.symbol}: "
                f"${current_price:.6f} (bid: ${bid_price:.6f}, ask: ${ask_price:.6f})"
            )
            return True

        except Exception as e:
            self.context.logger.exception(f"Error processing price responses: {e}")
            return False

    def _construct_trade_parameters(self) -> bool:
        """Construct complete trade parameters using CowSwap pricing."""
        try:
            symbol = self.trade_signal.get("symbol")
            trade_direction = self.trade_signal.get("direction", "buy")
            signal_strength = self.trade_signal.get("signal_strength", 0.5)

            token_info = self._get_token_info(symbol)
            if not token_info:
                return False

            position_size_usdc = self._calculate_position_size(signal_strength)

            current_price = self.market_data.get("current_price", 0)
            if current_price <= 0:
                self.context.logger.error("Invalid current price from CowSwap")
                return False

            slippage_tolerance = self._calculate_slippage_tolerance()
            stop_loss_price = self._calculate_stop_loss_price(current_price, trade_direction)
            take_profit_price = self._calculate_take_profit_price(current_price, trade_direction, stop_loss_price)

            token_quantity = position_size_usdc / current_price

            self.constructed_trade = {
                "trade_id": f"trade_{symbol}_{datetime.now(UTC).strftime('%Y%m%d_%H%M%S')}",
                "timestamp": datetime.now(UTC).isoformat(),
                "status": "constructed",
                # Asset details
                "symbol": symbol,
                "contract_address": token_info["address"],
                "coingecko_id": token_info["coingecko_id"],
                "trading_pair": f"{symbol}/USDC",
                # Trade direction and size
                "direction": trade_direction,
                "position_size_usdc": round(position_size_usdc, 2),
                "token_quantity": round(token_quantity, 6),
                # CowSwap pricing
                "entry_price": current_price,
                "bid_price": self.market_data.get("bid_price", current_price),
                "ask_price": self.market_data.get("ask_price", current_price),
                "cowswap_spread": self.market_data.get("spread", 0),
                # Risk management
                "stop_loss_price": round(stop_loss_price, 6),
                "take_profit_price": round(take_profit_price, 6),
                "slippage_tolerance": slippage_tolerance,
                # CowSwap execution parameters
                "execution_strategy": "cowswap",
                "exchange_id": "cowswap",
                "ledger_id": "base",
                "max_execution_time": 300,  # 5 minutes
                "partial_fills_allowed": True,
                # Order configuration for CowSwap
                "sell_token": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",  # USDC on Base
                "buy_token": token_info["address"],
                "sell_amount_usdc": position_size_usdc,
                "min_buy_amount": token_quantity * (1 - slippage_tolerance),
                # Signal context
                "signal_strength": signal_strength,
                "originating_signal": self.trade_signal.get("signal_id"),
                # Market data snapshot
                "market_data": self.market_data,
                # Risk parameters used
                "risk_parameters": self.risk_parameters,
            }

            return True

        except Exception as e:
            self.context.logger.exception(f"Failed to construct trade parameters: {e}")
            return False

    def _calculate_position_size(self, signal_strength: float) -> float:
        """Calculate position size based on signal strength and risk parameters."""
        try:
            # Get available trading capital from portfolio validation
            available_capital = getattr(self.context, "available_trading_capital", 5000.0)

            base_position_pct = 0.10  # 10% base allocation

            # Adjust based on signal strength (0.5 = neutral, 1.0 = very bullish, 0.0 = very bearish)
            strength_multiplier = signal_strength if signal_strength > 0.5 else (1 - signal_strength)
            position_pct = base_position_pct * (0.5 + strength_multiplier)  # Range: 5% - 15%

            # Calculate position size
            position_size = available_capital * position_pct

            # Apply min/max constraints
            min_size = self.risk_parameters["min_position_size"]
            max_size = min(self.risk_parameters["max_position_size"], available_capital * 0.20)  # Max 20% of capital

            position_size = max(min_size, min(position_size, max_size))

            self.context.logger.info(f"Calculated position size: ${position_size:.2f} (signal: {signal_strength:.2f})")
            return position_size

        except Exception as e:
            self.context.logger.exception(f"Failed to calculate position size: {e}")
            return self.risk_parameters["min_position_size"]

    def _calculate_slippage_tolerance(self) -> float:
        """Calculate slippage tolerance based on CowSwap market conditions."""
        try:
            # Base slippage from configuration
            base_slippage = self.risk_parameters["max_slippage"]

            # Adjust based on CowSwap spread
            spread = self.market_data.get("spread", 0)

            # Add spread to base slippage with minimum protection
            slippage = max(base_slippage, spread * 2.0)  # Use 2x spread as minimum
            slippage = min(slippage, 0.05)  # Cap at 5%

            return round(slippage, 4)

        except Exception as e:
            self.context.logger.exception(f"Failed to calculate slippage tolerance: {e}")
            return self.risk_parameters["max_slippage"]

    def _calculate_stop_loss_price(self, current_price: float, direction: str) -> float:
        """Calculate stop-loss price based on ATR and risk parameters."""
        try:
            # Get ATR-based stop loss multiplier
            atr_multiplier = self.risk_parameters["stop_loss_multiplier"]

            # Calculate ATR approximation from CowSwap market data
            high_24h = self.market_data.get("high_24h", current_price * 1.02)
            low_24h = self.market_data.get("low_24h", current_price * 0.98)
            estimated_atr = abs(high_24h - low_24h) / 2  # Simple ATR estimate

            # Ensure minimum ATR
            estimated_atr = max(estimated_atr, current_price * 0.015)  # Min 1.5% ATR

            stop_distance = estimated_atr * atr_multiplier

            stop_loss = current_price - stop_distance if direction == "buy" else current_price + stop_distance

            return max(stop_loss, 0.000001)  # Ensure positive price

        except Exception as e:
            self.context.logger.exception(f"Failed to calculate stop loss price: {e}")
            return current_price * 0.90 if direction == "buy" else current_price * 1.10

    def _calculate_take_profit_price(self, current_price: float, direction: str, stop_loss_price: float) -> float:
        """Calculate take-profit price based on risk-reward ratio."""
        try:
            # Calculate risk (distance to stop loss)
            if direction == "buy":
                risk = current_price - stop_loss_price
                reward = risk * self.risk_parameters["take_profit_ratio"]
                take_profit = current_price + reward
            else:  # sell
                risk = stop_loss_price - current_price
                reward = risk * self.risk_parameters["take_profit_ratio"]
                take_profit = current_price - reward

            return max(take_profit, 0.000001)  # Ensure positive price

        except Exception as e:
            self.context.logger.exception(f"Failed to calculate take profit price: {e}")
            return current_price * 1.20 if direction == "buy" else current_price * 0.80

    def _validate_constructed_trade(self) -> bool:
        """Validate the constructed trade for completeness and sanity."""
        try:
            errors = []

            # Perform all validation checks
            errors.extend(self._validate_required_fields())
            errors.extend(self._validate_price_relationships())
            errors.extend(self._validate_position_size())
            errors.extend(self._validate_slippage_tolerance())

            # Report all errors or success
            if errors:
                for error in errors:
                    self.context.logger.error(error)
                return False

            self.context.logger.info("Trade construction validation passed")
            return True

        except Exception as e:
            self.context.logger.exception(f"Failed to validate constructed trade: {e}")
            return False

    def _validate_required_fields(self) -> list[str]:
        """Validate that all required fields are present and valid."""
        required_fields = [
            "trade_id",
            "symbol",
            "contract_address",
            "direction",
            "position_size_usdc",
            "token_quantity",
            "entry_price",
            "stop_loss_price",
            "take_profit_price",
            "slippage_tolerance",
            "sell_token",
            "buy_token",
            "exchange_id",
            "ledger_id",
        ]

        errors = []
        for field in required_fields:
            if field not in self.constructed_trade:
                errors.append(f"Missing required field: {field}")
                continue

            value = self.constructed_trade[field]
            if value is None or (isinstance(value, int | float) and value <= 0):
                errors.append(f"Invalid value for {field}: {value}")

        return errors

    def _validate_price_relationships(self) -> list[str]:
        """Validate price relationships for buy orders."""
        errors = []

        if self.constructed_trade.get("direction") == "buy":
            entry = self.constructed_trade.get("entry_price", 0)
            stop = self.constructed_trade.get("stop_loss_price", 0)
            take_profit = self.constructed_trade.get("take_profit_price", 0)

            if stop >= entry:
                errors.append(f"Invalid stop loss: {stop} >= {entry}")

            if take_profit <= entry:
                errors.append(f"Invalid take profit: {take_profit} <= {entry}")

        return errors

    def _validate_position_size(self) -> list[str]:
        """Validate position size is within reasonable bounds."""
        errors = []
        position_size = self.constructed_trade.get("position_size_usdc", 0)

        if position_size < self.risk_parameters["min_position_size"]:
            errors.append(f"Position size too small: ${position_size}")

        if position_size > self.risk_parameters["max_position_size"]:
            errors.append(f"Position size too large: ${position_size}")

        return errors

    def _validate_slippage_tolerance(self) -> list[str]:
        """Validate slippage tolerance is within acceptable range."""
        errors = []
        slippage = self.constructed_trade.get("slippage_tolerance", 0)

        if slippage > 0.10:  # 10% max
            errors.append(f"Slippage tolerance too high: {slippage * 100:.2f}%")

        return errors

    def _store_constructed_trade(self) -> None:
        """Store the constructed trade for the ExecutionRound."""
        try:
            # Store in context for immediate access by ExecutionRound
            self.context.constructed_trade = self.constructed_trade

            # Also persist to storage
            if self.context.store_path:
                trades_file = self.context.store_path / "pending_trades.json"

                # Load existing pending trades
                pending_trades = {"trades": []}
                if trades_file.exists():
                    with open(trades_file, encoding="utf-8") as f:
                        pending_trades = json.load(f)

                # Add new trade
                pending_trades["trades"].append(self.constructed_trade)
                pending_trades["last_updated"] = datetime.now(UTC).isoformat()

                # Save updated trades
                with open(trades_file, "w", encoding="utf-8") as f:
                    json.dump(pending_trades, f, indent=2)

                self.context.logger.info(f"Stored constructed trade: {self.constructed_trade['trade_id']}")

        except Exception as e:
            self.context.logger.exception(f"Failed to store constructed trade: {e}")

    def _log_construction_summary(self) -> None:
        """Log a summary of the constructed trade."""
        try:
            trade = self.constructed_trade
            symbol = trade["symbol"]
            direction = trade["direction"]
            position_size = trade["position_size_usdc"]
            entry_price = trade["entry_price"]
            stop_loss = trade["stop_loss_price"]
            take_profit = trade["take_profit_price"]
            slippage = trade["slippage_tolerance"]

            self.context.logger.info("=== CowSwap Trade Construction Summary ===")
            self.context.logger.info(f"Trade ID: {trade['trade_id']}")
            self.context.logger.info(f"Asset: {symbol} ({trade['contract_address'][:10]}...)")
            self.context.logger.info(f"Direction: {direction.upper()}")
            self.context.logger.info(f"Position Size: ${position_size:.2f}")
            self.context.logger.info(f"Token Quantity: {trade['token_quantity']:.6f}")
            self.context.logger.info(f"Entry Price: ${entry_price:.6f}")
            self.context.logger.info(f"CowSwap Spread: {trade['cowswap_spread']:.4f}%")
            self.context.logger.info(f"Stop Loss: ${stop_loss:.6f}")
            self.context.logger.info(f"Take Profit: ${take_profit:.6f}")
            self.context.logger.info(f"Slippage Tolerance: {slippage * 100:.2f}%")
            self.context.logger.info(f"Exchange: {trade['exchange_id']} on {trade['ledger_id']}")

            # Calculate risk metrics
            risk_amount = abs(entry_price - stop_loss) * trade["token_quantity"]
            reward_amount = abs(take_profit - entry_price) * trade["token_quantity"]
            risk_reward_ratio = reward_amount / risk_amount if risk_amount > 0 else 0

            self.context.logger.info(f"Risk Amount: ${risk_amount:.2f}")
            self.context.logger.info(f"Reward Amount: ${reward_amount:.2f}")
            self.context.logger.info(f"Risk/Reward Ratio: 1:{risk_reward_ratio:.2f}")
            self.context.logger.info("==========================================")

        except Exception as e:
            self.context.logger.exception(f"Failed to log construction summary: {e}")


class ExecutionRound(BaseState):
    """This class implements the behaviour of the state ExecutionRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = MindshareabciappStates.EXECUTIONROUND

    def act(self) -> None:
        """Perform the act."""
        self.context.logger.info(f"Entering {self._state} state.")
        self._is_done = True
        self._event = MindshareabciappEvents.EXECUTED


class MindshareabciappFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._last_transition_timestamp: datetime | None = None
        self._previous_rounds: list[str] = []
        self._period_count: int = 0

        self.register_state(MindshareabciappStates.SETUPROUND.value, SetupRound(**kwargs), True)
        self.register_state(MindshareabciappStates.HANDLEERRORROUND.value, HandleErrorRound(**kwargs))
        self.register_state(MindshareabciappStates.DATACOLLECTIONROUND.value, DataCollectionRound(**kwargs))
        self.register_state(MindshareabciappStates.PORTFOLIOVALIDATIONROUND.value, PortfolioValidationRound(**kwargs))
        self.register_state(MindshareabciappStates.RISKEVALUATIONROUND.value, RiskEvaluationRound(**kwargs))
        self.register_state(MindshareabciappStates.PAUSEDROUND.value, PausedRound(**kwargs))
        self.register_state(MindshareabciappStates.CHECKSTAKINGKPIROUND.value, CheckStakingKPIRound(**kwargs))
        self.register_state(MindshareabciappStates.SIGNALAGGREGATIONROUND.value, SignalAggregationRound(**kwargs))
        self.register_state(MindshareabciappStates.POSITIONMONITORINGROUND.value, PositionMonitoringRound(**kwargs))
        self.register_state(MindshareabciappStates.ANALYSISROUND.value, AnalysisRound(**kwargs))
        self.register_state(MindshareabciappStates.TRADECONSTRUCTIONROUND.value, TradeConstructionRound(**kwargs))
        self.register_state(MindshareabciappStates.EXECUTIONROUND.value, ExecutionRound(**kwargs))

        self.register_transition(
            source=MindshareabciappStates.ANALYSISROUND.value,
            event=MindshareabciappEvents.DONE,
            destination=MindshareabciappStates.SIGNALAGGREGATIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.ANALYSISROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
            event=MindshareabciappEvents.DONE,
            destination=MindshareabciappStates.DATACOLLECTIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.DATACOLLECTIONROUND.value,
            event=MindshareabciappEvents.DONE,
            destination=MindshareabciappStates.POSITIONMONITORINGROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.DATACOLLECTIONROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.EXECUTIONROUND.value,
            event=MindshareabciappEvents.EXECUTED,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.EXECUTIONROUND.value,
            event=MindshareabciappEvents.FAILED,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.HANDLEERRORROUND.value,
            event=MindshareabciappEvents.RESET,
            destination=MindshareabciappStates.SETUPROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.HANDLEERRORROUND.value,
            event=MindshareabciappEvents.RETRIES_EXCEEDED,
            destination=MindshareabciappStates.PAUSEDROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.HANDLEERRORROUND.value,
            event=MindshareabciappEvents.RETRY,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.PAUSEDROUND.value,
            event=MindshareabciappEvents.RESET,
            destination=MindshareabciappStates.SETUPROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.PAUSEDROUND.value,
            event=MindshareabciappEvents.RESUME,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.PORTFOLIOVALIDATIONROUND.value,
            event=MindshareabciappEvents.AT_LIMIT,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.PORTFOLIOVALIDATIONROUND.value,
            event=MindshareabciappEvents.CAN_TRADE,
            destination=MindshareabciappStates.ANALYSISROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.PORTFOLIOVALIDATIONROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.POSITIONMONITORINGROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.POSITIONMONITORINGROUND.value,
            event=MindshareabciappEvents.EXIT_SIGNAL,
            destination=MindshareabciappStates.EXECUTIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.POSITIONMONITORINGROUND.value,
            event=MindshareabciappEvents.POSITIONS_CHECKED,
            destination=MindshareabciappStates.PORTFOLIOVALIDATIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.RISKEVALUATIONROUND.value,
            event=MindshareabciappEvents.APPROVED,
            destination=MindshareabciappStates.TRADECONSTRUCTIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.RISKEVALUATIONROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.RISKEVALUATIONROUND.value,
            event=MindshareabciappEvents.REJECTED,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.SETUPROUND.value,
            event=MindshareabciappEvents.DONE,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.SETUPROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.SIGNALAGGREGATIONROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.SIGNALAGGREGATIONROUND.value,
            event=MindshareabciappEvents.NO_SIGNAL,
            destination=MindshareabciappStates.CHECKSTAKINGKPIROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.SIGNALAGGREGATIONROUND.value,
            event=MindshareabciappEvents.SIGNAL_GENERATED,
            destination=MindshareabciappStates.RISKEVALUATIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.TRADECONSTRUCTIONROUND.value,
            event=MindshareabciappEvents.DONE,
            destination=MindshareabciappStates.EXECUTIONROUND.value,
        )
        self.register_transition(
            source=MindshareabciappStates.TRADECONSTRUCTIONROUND.value,
            event=MindshareabciappEvents.ERROR,
            destination=MindshareabciappStates.HANDLEERRORROUND.value,
        )

    def act(self) -> None:
        """Override act to track transitions."""
        if self.current is None:
            super().act()
            return

        # Store the current state before potential transition
        previous_state = self.current

        # Call parent act which handles the FSM logic
        super().act()

        # Check if a transition occurred
        if self.current != previous_state and self.current is not None:
            # A transition occurred - track it
            current_time = datetime.now(UTC)
            self._last_transition_timestamp = current_time

            # Track round history (keep last 25 rounds)
            if previous_state and previous_state not in self._previous_rounds[-1:]:  # Avoid duplicates
                self._previous_rounds.append(previous_state)
                if len(self._previous_rounds) > 25:
                    self._previous_rounds = self._previous_rounds[-25:]

            # Check if we transitioned back to data collection round (indicates a new operational period/cycle)
            if (
                self.current == MindshareabciappStates.DATACOLLECTIONROUND.value
                and previous_state != MindshareabciappStates.DATACOLLECTIONROUND.value
            ):
                self._period_count += 1
                self.context.logger.info(f"FSM started new operational period: {self._period_count}")

            self.context.logger.info(f"FSM transitioned from {previous_state} to {self.current}")

    @property
    def last_transition_timestamp(self) -> datetime | None:
        """Get the timestamp of the last transition."""
        return self._last_transition_timestamp

    @property
    def previous_rounds(self) -> list[str]:
        """Get the history of previous rounds."""
        return self._previous_rounds.copy()

    @property
    def period_count(self) -> int:
        """Get the current period count."""
        return self._period_count

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Mindshareabciapp FSM behaviour.")
        self._last_transition_timestamp = datetime.now(UTC)

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Mindshareabciapp FSM behaviour.")

    def terminate(self) -> None:
        """Implement the termination."""
        os._exit(0)
